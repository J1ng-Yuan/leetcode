## 🥓题目

<font color=orange>难度 ：中</font>

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

**示例 2:**

> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

**示例 3:**

> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
> 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

**示例 4:**

> 输入: s = ""
> 输出: 0

### 提示

- `0 <= s.length <= 5 * 10^4`
- `s` 由英文字母、数字、符号和空格组成



## 🥩题解

- **暴力思路：**

  枚举每个子串，扫描其中是否有重复字符，记录不含重复字符的最长字串的长度.

  时间复杂度$O(n^3)$

- **考虑优化**

  枚举带来复杂度的很高的提升，考虑能不能减少枚举或者判断

  观察`sub(i,j)`和`sub(i,j+1)`的区别，区别在于新增的`s[j+1]`，那么有两种可能：

  - `s[j+1]`和`sub(i,j)`中的字符都不同，那么这其实在告诉我们`sub(i,j+1)`是合法的

  - `s[j+1]`和`sub(i,j)`中某个字符相同，那么这其实在告诉我们`sub(i,j+1)`是不合法的，存在一个位置的字符和`s[j+1]`相同，这就可以得到一个重要推论：

    **存在k属于 [i,j]​使得s[k]==s[j+1]，而且sub(k+1,j+1)中没有重复的字符**

  想要知道`s[j+1]`是否在`[i,j]`中出现其实是很简单的，我们只需要维护一个map记录每一个字符上次出现是在哪里，当alphabet比较小的时候，一个数组就可以胜任这个工作。

  有了这个转移的想法可以尝试dp

  定义`dp[i]`是以i结尾的最长合法字串的长度，显然答案为`max(dp[i])`

  通过上面的分析可以得到

  定义k为s[j+1]上次出现的位置

  ````cpp
   if (k in s[i,j]) 
   	dp[j+1]=j+1-k 
   else 
       dp[j+1]=dp[j]+1 
  ````

  写的简单一点就是`dp[j+1]=min(j+1-k, dp[j]+1)` 

  为什么请读者自行思考一下

  > hint：看看if的条件满足和不满足时这两个式子的大小关系
  
  那么整体的算法可以如下描述：
  
  维护一个数组`pos[i]`记录`i`字符上次出现的位置，线性扫描字符串更新pos和dp，并更新最大值。
  
  

- 再优化一些

  可以发现`dp`这个数组其实只用到了用`dp[j]`更新`dp[j+1]`的特性，而且我们的答案是这些`dp[i]`中的最大值，这是可以在做的过程中更新的，所以做成一个数组也没必要，把它变成一个变量也够用了

  所以得到`dp=min(j+1-k, dp+1)`



总体时间复杂度O(n)​

空间复杂度O(|alphabet|)​



## 🍗代码



```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int N = s.length();
        int dp,pos[257],ret=0;
        memset(pos,-1,sizeof(pos));
        for (int i=0;i<N;i++)
        {
            if (i==0) dp=1;
            else dp=min(dp+1,i-pos[s[i]]);
            ret=max(dp,ret);
            pos[s[i]]=i;
        }
        return ret;
    }
};
```

